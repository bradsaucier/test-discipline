# Project Two - Summary and Reflections

This folder contains the Module 8 Project Two portfolio artifact for SNHU CS-320.

Author: Bradley Saucier, SMSgt, USAF (Ret.)
Course: SNHU CS-320 - Software Testing, Automation, and Quality Assurance

## Artifact

- PDF (authoritative submission): `Project-Two-Summary-Reflections.pdf`
- Markdown mirror (this file): optimized for GitHub viewing and quick review

Note: If the PDF date or metrics are updated, keep this mirror aligned.

## Executive summary

This artifact documents the unit testing approach used to verify the Contact, Task, and Appointment services using JUnit and rubric-derived requirements. The intent is verification-first: treat requirements as contracts, encode them as assertions, and prove both success paths and failure paths under repeatable execution.

The test strategy emphasizes boundary value analysis and equivalence partitioning to cover constrained fields, null handling, and service layer behaviors (uniqueness, update, delete). Tests are isolated with consistent setup to prevent state bleed and to keep failures attributable to a single condition.

Coverage results are reported as a snapshot at the time of writing. If future changes shift coverage by tenths of a percent, the controlling evidence is the CI output and the JaCoCo report generated by `mvn -B -Pci verify`.

## Reflection highlights

1. Functional and secure
I enforce input constraints at the boundary, fail fast on invalid state, and use unit tests plus a CI coverage gate to prevent regression. For public portfolio hygiene, dependencies are managed through Maven and monitored via Dependabot, and workflow permissions are scoped to the minimum required.

2. Interpret user needs
I translate user needs into testable constraints. For CS-320, the rubric and requirement documents are the specification, so each rule maps to named tests that a reviewer can trace back to the enforcing code.

3. Design approach
I design from invariants outward: define the data model, enforce constraints in domain objects, and keep the service layer deterministic and testable. I avoid unnecessary external dependencies so verification remains repeatable and auditable.
